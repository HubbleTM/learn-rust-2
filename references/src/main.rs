fn main() {
    /*
    * Синтаксическая конструкция &s1 позволяет создать ссылку,
    * которая ссылается на значение переменной s1, но не владеет ей.
    * Т.к. нет передачи владения, то значение на которое она указывает не будет удалено,
    * когда ссылка выйдет из области видимости функции.
    */
    let s1 = String::from("Hello world!");
    func1(&s1);

    // Мы должны поменять s добавив mut.
    let mut s2 = String::from("Hello world!");

    // Затем нужно создать изменяемую ссылку с помощью &mut s
    func2(&mut s2);


    // Можно иметь только одну изменяемую ссылочную переменную на часть данных
    // в определённой области видимости.

    let r1 = &mut s2;

    // Можем создать вторую так как первая на этой строке еще не использовалась.
    // Область видимости ссылочной переменной начинается от места,
    // где она создана и продолжается до места где она последний раз использована.
    let r2 = &mut s2;

    // Тут будет ошибка
    // println!("{} {}", r1, r2);
}

// Сигнатура функции использует & для индикации того, что тип параметра s является ссылкой.
fn func1(s: &String) { // s is a reference to a String - it is borrowing.
    println!("{}, length: {}", s, s.len());

    // Нельзя изменять данные по нуизменяемой ссылке.
    // s.push_str(" You can not do it");
} // Here, s goes out of scope.
// But because it does not have ownership of what it refers to, nothing happens.

// Принимаем изменяемую ссылку с помощью s: &mut String
fn func2(s: &mut String) {
    s.push_str(" You can do it!");
}


// Опастая функция которая возвращает недействительную ссылку.
fn func3() -> &String {
    let s = String::from("hello");
    &s
} // s будет удалена так как выходит из области видимости.
